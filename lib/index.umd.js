var A=Object.defineProperty;var _=s=>A(s,"__esModule",{value:!0});var L=(s,t)=>{_(s);for(var e in t)A(s,e,{get:t[e],enumerable:!0})};var n=Symbol("running"),u=!0,i=!1;var v=()=>!1,F=()=>{},G=()=>{},m=class{constructor({run:t=v,start:e=F,end:r=G,...a}){this.nodeType="Node";this.blueprint={run:t,start:e,end:r,...a}}run(t,{introspector:e,rerun:r=!1,registryLookUp:a=o=>o,...c}={}){r||this.blueprint.start(t);let o=this.blueprint.run(t,{...c,rerun:r,registryLookUp:a});return o!==n&&this.blueprint.end(t),e&&e.push(this,o,t),o}get name(){return this._name||this.blueprint.name}set name(t){this._name=t}};var N=class extends m{constructor(){super(...arguments);this.nodeType="Task"}};var T={};function P(){return T}function k(s){if(typeof s=="string"){let t=T[s];if(!t)throw new Error(`No node with name ${s} registered.`);return t}return s}var B=class{constructor({tree:t,blackboard:e}){this.tree=t,this.blackboard=e,this.lastResult=null}step({introspector:t}={}){let e=this.lastResult&&typeof this.lastResult=="object"?this.lastResult:[],r=this.lastResult===n||e.length>0;t&&t.start(this),this.lastResult=k(this.tree).run(this.blackboard,{indexes:e,introspector:t,rerun:r,registryLookUp:k}),t&&t.end()}static register(t,e){T[t]=typeof e=="function"?new N({name:t,run:e}):e}static cleanRegistry(){T={}}};var E={};L(E,{AlwaysFailDecorator:()=>g,AlwaysSucceedDecorator:()=>y,CooldownDecorator:()=>S,InvertDecorator:()=>C,LoopDecorator:()=>b});var l=class extends m{constructor({config:t={},...e}={config:{}}){super(e);this.nodeType="Decorator";this.setConfig(t)}decorate(t,e,r){return t(t,e,r)}run(t,{introspector:e,rerun:r,registryLookUp:a=o=>o,...c}={}){r||this.blueprint.start(t);let o=0,p=this.decorate(()=>(++o,a(this.blueprint.node).run(t,{...c,rerun:r,introspector:e,registryLookUp:a})),t,this.config);return p!==n&&this.blueprint.end(t),e&&e.wrapLast(o,this,p,t),p}setConfig(t){this.config=t}};var g=class extends l{constructor(){super(...arguments);this.nodeType="AlwaysFailDecorator"}decorate(t){return t()===n?n:i}};var y=class extends l{constructor(){super(...arguments);this.nodeType="AlwaysSucceedDecorator"}decorate(t){return t()===n?n:u}};var S=class extends l{constructor(){super(...arguments);this.lock=!1;this.nodeType="CooldownDecorator"}setConfig({cooldown:t=5}){this.config={cooldown:t}}decorate(t){return this.lock?i:(this.lock=!0,setTimeout(()=>{this.lock=!1},this.config.cooldown*1e3),t())}};var C=class extends l{constructor(){super(...arguments);this.nodeType="InvertDecorator"}decorate(t){let e=t();return e===n?n:e===u?i:u}};var b=class extends l{constructor(){super(...arguments);this.nodeType="LoopDecorator"}setConfig({loop:t=1/0}){this.config={loop:t}}decorate(t){let e=0,r=i;for(;e++<this.config.loop;)if(r=t(),r===i)return i;return r}};var f=class extends m{constructor(t){super(t);this.OPT_OUT_CASE=u;this.START_CASE=u;this.nodeType="BranchNode";this.nodes=t.nodes||[],this.numNodes=this.nodes.length,this.wasRunning=!1}run(t={},{indexes:e=[],introspector:r,rerun:a,registryLookUp:c=o=>o}={}){a||this.blueprint.start(t);let o=this.START_CASE,p=e.shift()||0;for(;p<this.numNodes;){let h=c(this.nodes[p]).run(t,{indexes:e,introspector:r,rerun:a,registryLookUp:c});if(h===n){this.wasRunning=!0,o=[p,...e];break}else if(typeof h=="object"){o=[...e,p,...h];break}else if(h===this.OPT_OUT_CASE){o=h;break}else this.wasRunning=!1,a=!1,++p}let R=o===n||typeof o=="object";if(R||this.blueprint.end(t),r){let d=R?n:o;r.wrapLast(Math.min(p+1,this.numNodes),this,d,t)}return o}};var x=class extends f{constructor(){super(...arguments);this.nodeType="Random"}run(t={},{indexes:e=[],introspector:r,rerun:a,registryLookUp:c=o=>o}={}){a||this.blueprint.start(t);let o=e.shift()||0;a||(o=Math.floor(Math.random()*this.numNodes));let R=c(this.nodes[o]).run(t,{indexes:e,introspector:r,rerun:a,registryLookUp:c}),d=R;R===n?d=[o,...e]:typeof R=="object"&&(d=[...e,o,...R]);let h=d===n||typeof d=="object";if(h||this.blueprint.end(t),r){let O=h?n:d;r.wrapLast(1,this,O,t)}return d}};var D=class extends f{constructor(){super(...arguments);this.nodeType="Selector";this.START_CASE=i;this.OPT_OUT_CASE=u}};var I=class extends f{constructor(){super(...arguments);this.nodeType="Sequence";this.START_CASE=u;this.OPT_OUT_CASE=i}};var w=class{constructor(){this.types={task:N,decorator:l,selector:D,sequence:I,random:x,invert:C,fail:g,succeed:y,cooldown:S,loop:b}}defineType(t,e){this.types[t]=e}parse(t){let{type:e,name:r,...a}=t,c=this.types[e];if(!c){let o=k(e);if(o)return o.name=r,o;throw new Error(`Don't know how to handle type ${e}. Please register this first.`)}return new c({name:r,node:t.node?this.parse(t.node):null,nodes:t.nodes?t.nodes.map(o=>this.parse(o)):null,config:a})}};var U=class{constructor(){this.currentResult=[],this.results=[]}start(t){this.tree=t,this.currentResult=[]}end(){let t=this.currentResult.pop();t&&this.results.push(t),delete this.tree,this.currentResult=[]}push(t,e,r){this.currentResult.push(this._toResult(t,e,r))}wrapLast(t,e,r,a){let c=this.currentResult.splice(this.currentResult.length-t,t);this.currentResult.push({...this._toResult(e,r,a),children:c})}_toResult(t,e,r){return{...t.name?{name:t.name}:{},result:e}}reset(){this.results=[]}get lastResult(){return this.results.length===0?null:this.results[this.results.length-1]}};var ee=B;export{B as BehaviorTree,w as BehaviorTreeImporter,f as BranchNode,l as Decorator,i as FAILURE,U as Introspector,m as Node,n as RUNNING,x as Random,u as SUCCESS,D as Selector,I as Sequence,N as Task,E as decorators,ee as default,P as getRegistry,k as registryLookUp};
//# sourceMappingURL=index.umd.js.map
